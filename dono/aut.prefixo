export default {
  name: "prefixo",
  run: async (sock, msg, args) => {
    try {
      const fs = await import("fs")
      const path = await import("path")
      const prefixPath = path.join(process.cwd(), "prefixo.json")
      const from = msg.key.remoteJid
      const isGroup = from.endsWith("@g.us")

      // ğŸ”§ Cria prefixo.json se nÃ£o existir
      if (!fs.existsSync(prefixPath)) {
        fs.writeFileSync(prefixPath, JSON.stringify({ prefixo: "!" }, null, 2))
      }

      // ğŸ“– LÃª prefixo atual
      const dados = JSON.parse(fs.readFileSync(prefixPath))
      const prefixoAtual = dados.prefixo || "!"

      // âš ï¸ Se o usuÃ¡rio sÃ³ digitou /prefixo, mostra o atual
      if (!args[0]) {
        await sock.sendMessage(from, { text: `âš™ï¸ O prefixo atual Ã©: *${prefixoAtual}*` })
        return
      }

      // âš™ï¸ Novo prefixo informado
      const novoPrefixo = args[0].trim()

      // ğŸ‘‘ Se for grupo, verifica se Ã© admin
      if (isGroup) {
        const groupMetadata = await sock.groupMetadata(from)
        const sender = msg.key.participant || msg.participant || msg.key.remoteJid
        const admins = groupMetadata.participants
          .filter(p => p.admin === "admin" || p.admin === "superadmin")
          .map(p => p.id)
        const isAdmin = admins.includes(sender)

        if (!isAdmin) {
          await sock.sendMessage(from, { text: "ğŸš« Apenas administradores podem mudar o prefixo!" })
          return
        }
      }

      // âœï¸ Salva o novo prefixo
      fs.writeFileSync(prefixPath, JSON.stringify({ prefixo: novoPrefixo }, null, 2))

      await sock.sendMessage(from, { text: `âœ… Prefixo alterado com sucesso!\nğŸ“Œ Novo prefixo: *${novoPrefixo}*` })
    } catch (e) {
      console.error(e)
      await sock.sendMessage(msg.key.remoteJid, { text: "âŒ Erro ao atualizar o prefixo." })
    }
  }
}
